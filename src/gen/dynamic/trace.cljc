(ns gen.dynamic.trace
  (:refer-clojure :exclude [=])
  (:require [clojure.core :as core]
            [gen.diff :as diff]
            [gen.choice-map :as cm]
            [gen.dynamic.choice-map :as dynamic.choice-map]
            [gen.generative-function :as gf]
            [gen.trace :as trace])
  #?(:cljs
     (:require-macros [gen.dynamic.trace])))

(defn no-op
  ([gf args]
   (apply gf args))
  ([_k gf args]
   (apply gf args)))

(def ^:dynamic *trace*
  "Applies the generative function gf to args. Dynamically rebound by functions
  like `gf/simulate`, `gf/generate`, `trace/update`, etc."
  no-op)

(defn active-trace
  "Returns the currently-active tracing function, bound to [[*trace*]].

  NOTE: Prefer `([[active-trace]])` to `[[*trace*]]`, as direct access to
  `[[*trace*]]` won't reflect new bindings when accessed inside of an SCI
  environment."
  [] *trace*)

;; ## Primitive Trace
;;
;; [[Trace]] above tracks map-like associations of address to traced value. At
;; the bottom of the tree represented by these associations is a primitive
;; trace, usually generated by a primitive probability distribution.
;;
;; [[PrimitiveTrace]] is a simplified version of [[Trace]] (and an implementer
;; of the [[gen.trace/ITrace]] interface) designed for a single value.

(defrecord PrimitiveTrace [gen-fn args val score]
  trace/ITrace
  (get-args [_] args)
  (get-retval [_] val)
  (get-choices [_] (cm/->Choice val))
  (get-gen-fn [_] gen-fn)
  (get-score [_] score)

  trace/IUpdate
  (-update [_ _ _ constraint]
    (-> (gf/generate gen-fn args constraint)
        (update :weight - score)
        (core/assoc :change  diff/unknown-change
                    :discard val))))


(declare trace =)

;; ## Choice Map for address-like trace

(defrecord Call [subtrace score noise])

(deftype ChoiceMap [m]
  cm/IChoiceMap
  (-has-value? [_] false)
  (-get-value [_] nil)
  (has-submap? [m k] (contains? m k))
  (get-submap [m k]
    (let [v (get m k)]
      (cond (instance? Call v)
            (trace/get-choices (:subtrace v))

            (map? v)
            (ChoiceMap. v)

            :else cm/EMPTY)))

  (get-values-shallow [_]
    (persistent!
     (reduce-kv
      (fn [acc k v]
        (if (instance? Call v)
          (let [m (trace/get-choices (:subtrace v))]
            (if (cm/has-value? m)
              (assoc! acc k (cm/get-value m))
              acc))
          acc))
      (transient {})
      m)))

  (get-submaps-shallow [_]
    (persistent!
     (reduce-kv
      (fn [acc k v]
        (assoc! acc k
                (if (instance? Call v)
                  (trace/get-choices (:subtrace v))
                  (ChoiceMap. v))))
      (transient {})
      m))))

(deftype Trace [gen-fn trie score noise args retval]
  trace/ITrace
  (get-args [_] args)
  (get-retval [_] retval)
  (get-gen-fn [_] gen-fn)
  (get-choices [_] (->ChoiceMap trie))
  (get-score [_] score))

(defn trace
  "new trace.

  TODO pad args with defaults if available."
  [gen-fn args]
  (Trace. gen-fn {} 0.0 0.0 args nil))

(defn validate-empty! [m addr]
  (when (contains? m addr)
    (throw (ex-info "Value or subtrace already present at address. The same
                      address cannot be reused for multiple random choices."
                    {:addr addr}))))

(defn with-retval [^Trace trace retval]
  (Trace. (.-gen-fn trace)
          (.-trie trace)
          (.-score trace)
          (.-noise trace)
          (.-args trace)
          retval))

(defn add-call
  "TODO handle noise."
  [^Trace trace k subtrace]
  (let [trie (.-trie trace)]
    (validate-empty! trie k)
    (let [score (trace/get-score subtrace)
          noise 0.0 #_ (trace/project subtrace nil)
          call  (->Call subtrace score noise)]
      (Trace. (.-gen-fn trace)
              (assoc trie k call)
              (+ (.-score trace) score)
              (+ (.-noise trace) noise)
              (.-args trace)
              (.-retval trace)))))

(defn ^:no-doc = [^Trace this that]
  (and (instance? Trace that)
       (let [^Trace that that]
         (and (core/= (.-gen-fn this) (.-gen-fn that))
              (core/= (.-trie this) (.-trie that))
              (core/= (.-score this) (.-score that))
              (core/= (.-noise this) (.-noise that))
              (core/= (.-args this) (.-args that))
              (core/= (.-retval this) (.-retval that))))))

;; ## Update State
(defn ^:no-doc combine
  "combine by adding weights?"
  [v k {:keys [trace weight discard]}]
  (-> v
      (update :trace add-call k trace)
      (update :weight + weight)
      (cond-> discard (update :discard assoc k discard))))

;; ## Update impl
(extend-type Trace
  trace/IUpdate
  (-update [this _ _ constraints]
    ;; TODO this feels weird that we need something like this...
    ;;
    ;; TODO can we add exec to the protocol?
    (let [^gen.dynamic.DynamicDSLFunction gen-fn (trace/get-gen-fn this)
          state (atom {:trace (trace gen-fn (trace/get-args this))
                       :weight 0
                       :discard (dynamic.choice-map/choice-map)})]
      (binding [*trace*
                ;; TODO this needs a major redo to match the interface.
                (fn
                  ([^gen.dynamic.DynamicDSLFunction gf args]
                   (apply (.-clojure-fn gf) args))
                  ([k gen-fn args]
                   (validate-empty! (:trace @state) k)
                   (let [k-constraints (cm/get-submap constraints k)
                         {subtrace :trace :as ret}
                         (if-let [prev-subtrace (get (.-trie this) k)]
                           (trace/update prev-subtrace k-constraints)
                           (gf/generate gen-fn args k-constraints))]
                     (swap! state combine k ret)
                     (trace/get-retval subtrace))))]
        (let [retval (apply (.-clojure-fn gen-fn) (trace/get-args this))
              {:keys [trace weight discard]} @state
              unvisited (apply dissoc
                               (trace/get-choices this)
                               (keys (trace/get-choices trace)))]

          {:trace (with-retval trace retval)
           :change diff/unknown-change
           :weight weight
           :discard (merge discard unvisited)})))))
