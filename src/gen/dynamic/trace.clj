(ns gen.dynamic.trace
  (:require [clojure.set :as set]
            [gen.choice-map :as choice-map]
            [gen.dynamic.choice-map :as dynamic.choice-map]
            [gen.generative-function :as gf]
            [gen.trace :as trace]))

(defn ^:no-doc no-op
  ([gf args]
   (apply gf args))
  ([_k gf args]
   (apply gf args)))

(def ^:dynamic *trace*
  "Applies the generative function gf to args. Dynamically rebound by functions
  like `gf/simulate`, `gf/generate`, `trace/update`, etc."
  no-op)

(def ^:dynamic *splice*
  "Applies the generative function gf to args. Dynamically rebound by functions
  like `gf/simulate`, `gf/generate`, `trace/update`, etc."
  no-op)

(defmacro untraced
  [& body]
  `(binding [*trace*  no-op
             *splice* no-op]
     ~@body))

(declare assoc-subtrace trace update-trace with-val compute-score)

(deftype Trace [gf args subtraces retval]
  clojure.lang.Associative
  (containsKey [_ k]
    (contains? subtraces k))
  (entryAt [_ k]
    (.entryAt subtraces k))

  clojure.lang.Counted
  (count [_]
    (count subtraces))

  clojure.lang.IFn
  (invoke [this k]
    (.valAt this k))

  clojure.lang.ILookup
  (valAt [this k]
    (get (trace/choices this) k))
  (valAt [this k not-found]
    (get (trace/choices this) k not-found))

  clojure.lang.IMapIterable
  (keyIterator [this]
    (.iterator
     ^java.lang.Iterable
     (keys (trace/choices this))))
  (valIterator [this]
    (.iterator
     ^java.lang.Iterable
     (vals (trace/choices this))))

  clojure.lang.Seqable
  (seq [this]
    (seq (trace/choices this)))

  java.lang.Iterable
  (iterator [this]
    (.iterator
     (let [^clojure.lang.Seqable choice-map (trace/choices this)]
       ^java.lang.Iterable (.seq choice-map))))

  trace/GenFn
  (gf [_] gf)

  trace/Args
  (args [_] args)

  trace/RetVal
  (retval [_] retval)

  trace/Choices
  (choices [_]
    (dynamic.choice-map/->ChoiceMap
     (update-vals subtraces trace/choices)))

  trace/Score
  (score [this]
    (compute-score this))

  trace/Update
  (update [this constraints]
    (update-trace this constraints)))

;; ## Constructors

(defn trace
  "Returns a new, unfulfilled [[Trace]] wrapping the supplied generative function
  and its arguments."
  [gf args]
  (->Trace gf args {} nil))

;; ## Predicates

(defn trace?
  "Returns `true` if `t` is an instance of [[Trace]], false otherwise."
  [t]
  (instance? Trace t))

;; ## Functions

(defn compute-score
  "Returns the score of this trace.

  The score is generated by summing the scores of all traced values."
  [^Trace t]
  ;; TODO Handle untraced randomness.
  (let [v (vals (.-subtraces t))]
    (transduce (map trace/score) + 0.0 v)))

(defn with-val [^Trace t v]
  (->Trace (.-gf t) (.-args t) (.-subtraces t) v))

(defn ^:no-doc combine
  "combine by adding weights?"
  [l k {:keys [trace weight discard] :as r}]
  (-> l
      (update :trace assoc-subtrace k trace)
      (update :weight + weight)
      (cond-> (contains? r :discard) (update :discard assoc k discard))))

(defn update-trace [this constraints]
  (let [gf    (trace/gf this)
        state (atom {:trace (trace gf (trace/args this))
                     :weight 0
                     :discard (dynamic.choice-map/choice-map)})]
    (binding [*splice*
              (fn [_gf _args]
                (throw (ex-info "Not yet implemented." {})))

              *trace*
              (fn [k gf args]
                (let [sub-ms        (choice-map/submaps constraints)
                      k-constraints (get sub-ms k)
                      ret           (if-let [prev-subtrace (get (.-subtraces ^Trace this) k)]
                                      ;; TODO why don't we use `gf` or `args`?
                                      (trace/update prev-subtrace k-constraints)
                                      (gf/generate gf args k-constraints))]
                  (swap! state combine k ret)
                  (trace/retval (:trace ret))))]
      (let [retval (apply (:clojure-fn gf) (trace/args this))
            {:keys [trace weight discard]} @state
            unvisited (select-keys
                       (trace/choices this)
                       (set/difference
                        (set (keys (trace/choices this)))
                        (set (keys (trace/choices trace)))))]
        {:trace (with-val trace retval)
         :weight  weight
         :discard (merge discard unvisited)}))))

(defn assoc-subtrace
  [^Trace t addr subt]
  (let [subtraces (.-subtraces t)]
    (when (contains? subtraces addr)
      (throw (ex-info "Value or subtrace already present at address. The same
                      address cannot be reused for multiple random choices."
                      {:addr addr})))
    (->Trace (.-gf t)
             (.-args t)
             (assoc subtraces addr subt)
             (.-retval t))))

(defn merge-subtraces
  [^Trace t1 ^Trace t2]
  (reduce-kv assoc-subtrace
             t1
             (.-subtraces t2)))
